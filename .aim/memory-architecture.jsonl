{"type":"_aim","source":"mcp-knowledge-graph"}
{"type":"entity","name":"Kasal","entityType":"project","observations":["AI agent workflow orchestration platform","Clean architecture pattern: Frontend -> API -> Services -> Repositories -> Database","FastAPI + React + CrewAI framework","Supports multiple LLM providers (Databricks, OpenAI, Anthropic)","JWT authentication with Databricks OAuth","Current development focus: Stop execution feature","Recent work on knowledge integration","Vector search capabilities added","Active feature branch: feature/stop-execution","Successfully migrated from complex 4-tier RBAC to simplified 3-tier role system","Removed all complex privilege mappings and external identity providers","Implemented decorator-based permission enforcement with @require_roles()","Simplified authentication flows with group-scoped role management","Database migration completed: dropped 6 complex RBAC tables (privileges, roles, role_privileges, external_identities, identity_providers, user_roles)","Architecture now uses clean decorator pattern for permissions instead of complex privilege lookup","Knowledge graph updated to reflect major architectural changes","Removed complex RBAC system in favor of simplified 3-tier roles","Migrated to tool-based knowledge search approach","Added Lakebase integration for Databricks Apps deployment","Implemented X-Forwarded-Email authentication pattern","Updated frontend with new permission system and Zustand stores"]}
{"type":"entity","name":"Backend","entityType":"component","observations":["FastAPI + SQLAlchemy 2.0 + Alembic","Python 3.9+","Clean architecture layers","Async-first operations","Auto-reloads with --reload flag"]}
{"type":"entity","name":"Frontend","entityType":"component","observations":["React 18 + TypeScript + Material-UI + ReactFlow","Hot module replacement (HMR)","Copies docs from src/docs/ to public/docs/","Built assets stored in frontend_static/","Updated with two new Zustand stores for improved state management","Migrated from local useState to global Zustand stores for chat messages","Implemented real-time configuration updates without screen refresh","Fixed duplicate message display issues in chat interface","Added event-driven configuration management for knowledge sources","Enhanced user experience with immediate UI updates on configuration changes","KnowledgeFileUpload component uses Zustand store for agent state management","Tool display names handled through special case for DatabricksKnowledgeSearchTool","Knowledge source configuration tied to tool enable/disable in DatabricksConfiguration","Automatic tool state sync when knowledge_volume_enabled changes"]}
{"type":"entity","name":"CrewAI_Engine","entityType":"ai_framework","observations":["Agent orchestration framework","Deterministic crew IDs for memory persistence","Group isolation for tenant data separation","Databricks Vector Search integration"]}
{"type":"entity","name":"Database","entityType":"persistence","observations":["SQLite for development","PostgreSQL for production","Alembic migrations","SQLAlchemy 2.0 ORM","UPDATED: Now supports multi-database architecture","Can route between SQLite, PostgreSQL, and Lakebase","Database selection handled by DatabaseRouter component","Lakebase support added for Databricks Apps deployment"]}
{"type":"entity","name":"CleanArchitecture","entityType":"pattern","observations":["Separation of concerns across layers","Frontend -> API -> Services -> Repositories -> Database","Service layer contains business logic","Repository pattern for data access","Dependency inversion principle applied"]}
{"type":"entity","name":"AsyncOperations","entityType":"requirement","observations":["All I/O operations must be async","Non-blocking operations required","Python asyncio used throughout","FastAPI async endpoints","Database operations use async SQLAlchemy"]}
{"type":"entity","name":"VectorKnowledgeSystem","entityType":"subsystem","observations":["Integrates with CrewAI framework for agent knowledge sources","Uses Databricks Vector Search document_index for knowledge storage","Implements multi-tenant isolation via group_id filtering","Supports agent-based access control for knowledge documents","Execution isolation prevents knowledge leakage between crew runs","Source filtering limits search results to specific uploaded files","Repository pattern with DatabricksVectorIndexRepository for Vector Search operations","Schema-based approach with four memory types: short_term, long_term, entity, document","Authentication hierarchy: OBO tokens → PAT from database → environment variables","File upload and immediate embedding pipeline for knowledge ingestion","UPDATED: No longer uses CrewAI knowledge sources integration","Now accessed via DatabricksKnowledgeSearchTool","Tool provides explicit control over knowledge retrieval timing","Repository pattern with DatabricksVectorIndexRepository unchanged","File upload and embedding pipeline remains the same"]}
{"type":"entity","name":"EnvironmentConfig","entityType":"configuration","observations":["Environment variable management","Development/staging/production settings","Database connection strings","API keys and secrets","Feature flags and toggles"]}
{"type":"entity","name":"DatabaseConfig","entityType":"configuration","observations":["SQLAlchemy configuration","Connection pooling settings","Migration configuration","Backup and recovery settings","Performance tuning parameters"]}
{"type":"entity","name":"LoggingConfig","entityType":"configuration","observations":["Log level configuration","Output format settings","File rotation policies","External logging service integration","Performance monitoring setup"]}
{"type":"entity","name":"SecurityConfig","entityType":"configuration","observations":["CORS settings","JWT secret keys","OAuth configuration","Rate limiting settings","API security policies"]}
{"type":"entity","name":"DatabricksConfig","entityType":"configuration","observations":["Databricks workspace settings","Authentication tokens","Volume and catalog configurations","Vector search endpoints","Compute cluster settings","Now dispatches databricks-config-updated events on configuration save","Integrated with global KnowledgeConfigZustandStore for real-time updates","Enhanced with event-driven configuration change notifications","Supports immediate UI updates across all components on config changes"]}
{"type":"entity","name":"BuildConfig","entityType":"configuration","observations":["Frontend build configuration","Asset optimization settings","Bundle splitting rules","Environment-specific builds","Deployment configurations"]}
{"type":"entity","name":"AppYaml","entityType":"configuration","observations":["Application deployment manifest","Databricks app configuration","Resource requirements","Environment variables","Service dependencies"]}
{"type":"entity","name":"RequirementsTxt","entityType":"configuration","observations":["Python package dependencies","Version constraints","Development vs production packages","Security and compatibility requirements","Dependency resolution"]}
{"type":"entity","name":"UnitTests","entityType":"test_infrastructure","observations":["pytest-based unit testing","Service layer testing","Repository pattern testing","Mock and fixture management","Coverage reporting and metrics"]}
{"type":"entity","name":"IntegrationTests","entityType":"test_infrastructure","observations":["API endpoint testing","Database integration testing","External service integration","End-to-end workflow testing","Test database setup and teardown"]}
{"type":"entity","name":"FrontendTests","entityType":"test_infrastructure","observations":["Jest and React Testing Library","Component unit testing","User interaction testing","Accessibility testing","Visual regression testing"]}
{"type":"entity","name":"TestFixtures","entityType":"test_infrastructure","observations":["Test data management","Database seeding and cleanup","Mock API responses","Test user accounts","Reusable test scenarios"]}
{"type":"entity","name":"AlembicMigrations","entityType":"database_infrastructure","observations":["Database migration system using Alembic","Located in src/backend/migrations/","Version-controlled schema changes","Migration scripts in migrations/versions/","Configuration in alembic.ini"]}
{"type":"entity","name":"DatabaseSession","entityType":"database_infrastructure","observations":["SQLAlchemy session management","Located in src/backend/src/db/session.py","Database connection handling","Session factory and lifecycle","Connection pooling configuration"]}
{"type":"entity","name":"DatabaseBase","entityType":"database_infrastructure","observations":["Base database configuration","Located in src/backend/src/db/base.py","SQLAlchemy declarative base","Common model patterns","Database initialization"]}
{"type":"entity","name":"AllModels","entityType":"database_infrastructure","observations":["Central model registry","Located in src/backend/src/db/all_models.py","Imports all database models","Model discovery for migrations","Schema generation support"]}
{"type":"entity","name":"FastAPI_Backend","entityType":"subsystem","observations":["RESTful API layer built with FastAPI","Handles HTTP requests and responses","Implements clean architecture patterns","Async/await throughout for non-blocking operations"]}
{"type":"entity","name":"ProcessCrewExecutor","entityType":"service","observations":["Service layer for executing CrewAI crews in isolated processes","Manages subprocess lifecycle and communication","Handles crew execution results and status updates","Integrates with CrewAIEngineService for orchestration"]}
{"type":"entity","name":"Clean_Architecture","entityType":"pattern","observations":["Separation of concerns across layers","FastAPI -> Services -> Repositories -> Database flow","Dependency inversion principle applied","Domain logic isolated from infrastructure concerns"]}
{"type":"entity","name":"LLM_Manager","entityType":"service","observations":["Centralized LLM provider management","Supports multiple providers: Databricks, OpenAI, Anthropic","Configuration-driven model selection","Integration with CrewAI LLM abstraction"]}
{"type":"entity","name":"Databricks_Integration","entityType":"integration","observations":["Primary LLM provider through Databricks","Vector Search for embeddings and similarity","Unity Catalog for data governance","OAuth authentication integration"]}
{"type":"entity","name":"ClaudeCodeHooksSystem","entityType":"automation_system","observations":["Comprehensive workflow enforcement system","Automatic blocking of operations without knowledge graph consultation","PreToolUse, PostToolUse, and Session lifecycle hooks","Compliance validation and monitoring","Auto-update queue for knowledge graph maintenance","Addresses core issue: 'why is claude not using the graph search'","IMPLEMENTED: Active hooks system with knowledge graph enforcement","PreToolUse hooks block file operations without KG consultation","PostToolUse hooks remind to update KG after file changes","SessionStart hooks enforce mandatory project context loading","Configuration in .claude/settings.json with enforcement rules","Enforcement script: .claude/hooks/knowledge-graph-enforcement.py","Logging system for compliance tracking and debugging","Addresses core issue: automatic enforcement of CLAUDE.md workflow"]}
{"type":"entity","name":"ServiceArchitecturePattern","entityType":"pattern","observations":["Frontend API → Router Layer → Service Layer → Repository Layer → Database/Backend API","Service layer contains business logic and orchestration","Repository layer abstracts data access and external API calls","Unit of Work pattern for transaction management","Dependency injection through FastAPI's DI system","All operations are async and non-blocking","Knowledge graph alignment completed - all routers properly delegate to services","Code verification confirmed: AuthRouter→AuthService, AgentsRouter→AgentService, TemplatesRouter→TemplateService, ExecutionsRouter→ExecutionService, CrewsRouter→CrewService","Removed incorrect relations showing routers bypassing service layer","Architecture compliance verified across all API endpoints"]}
{"type":"entity","name":"UnitOfWorkPattern","entityType":"pattern","observations":["Transaction management for complex operations","Ensures atomicity across multiple repository operations","Implemented through SQLAlchemy async sessions","Used in services for multi-step database operations","Rollback capability for failed operations","Located in core/dependencies.py and base services","Implemented through SQLAlchemy AsyncSession in repositories","BaseRepository handles transaction lifecycle: session.flush() → session.commit()","Automatic rollback on exceptions in all repository operations","Each operation commits immediately for data consistency","Session passed from dependencies.py through service to repository","Repository operations: create(), add(), update(), delete() all handle transactions","Error handling with try/catch and session.rollback() on failures","Session-scoped transaction management spanning entire HTTP request lifecycle","get_db() dependency provides AsyncSession with automatic commit/rollback","Repositories use flush() to participate in transaction without controlling boundaries","Enables atomic operations across multiple repositories in a single service method","Critical for CrewAI operations: execution records + memory + logs must succeed/fail together","Prevents orphaned data when complex multi-step operations partially fail","Two-tier error handling: repository-level for logging, session-level for transaction control","Supports async operations with consistent transaction context across concurrent calls","Essential for data integrity in AI orchestration where partial states cause unpredictable behavior","Abstracts transaction semantics enabling SQLite/PostgreSQL portability"]}
{"type":"entity","name":"DependencyInjectionPattern","entityType":"pattern","observations":["Uses FastAPI's built-in DI system with Annotated types","Factory functions for repositories and services","SessionDep = Annotated[AsyncSession, Depends(get_db)]","GroupContextDep = Annotated[GroupContext, Depends(get_group_context)]","get_repository() and get_service() factory functions","Consistent initialization pattern across all services","get_group_context() extracts GroupContext from HTTP headers","Supports both Databricks Apps and OAuth2-Proxy headers","Fallback to admin@admin.com in DEBUG_MODE for local development","get_repository() factory creates repository instances with model and session","get_service() factory creates service instances with session and repositories","get_log_service() singleton factory for LLMLogService","Error handling with fallback initialization patterns in get_service()","Built on FastAPI's native Depends() mechanism with custom factory functions","Annotated type hints create self-documenting, type-safe dependency declarations","SessionDep automatically injects request-scoped database sessions with transaction management","GroupContextDep extracts multi-tenant context from HTTP headers (Databricks Apps/OAuth2-Proxy)","Factory functions (get_repository, get_service) are higher-order functions returning dependency callables","Constructor injection pattern - services receive dependencies through __init__ not internal creation","Dependency chain: Routes → Services → Repositories → Sessions → Database","Smart session selection between regular DB and Lakebase based on configuration","Error handling with fallback patterns for flexible service initialization","Inversion of control enables easy testing with mocked dependencies","Request lifecycle: FastAPI creates session → extracts context → injects service → calls handler → manages transaction","Type safety catches dependency errors at development time not runtime"]}
{"type":"entity","name":"RepositoryPattern","entityType":"pattern","observations":["All database access through repositories","BaseRepository class with common CRUD operations","Repository classes extend BaseRepository with model-specific methods","Async database operations using SQLAlchemy 2.0","Repository initialization: repository_class(model_class, session)","Used by services to access data without direct DB coupling"]}
{"type":"entity","name":"BaseRepository","entityType":"base_class","observations":["Core base class for all repositories","Located in src/core/base_repository.py","Provides common CRUD operations","Async database operations using SQLAlchemy","Constructor takes model_class and session parameters","Extended by all repository implementations","Implements Unit of Work pattern through SQLAlchemy sessions","All operations handle transaction lifecycle","Automatic rollback on exceptions","Commit after flush to ensure persistence","Support for both int and UUID primary keys","Generic type support with ModelType bound to Base"]}
{"type":"entity","name":"BaseService","entityType":"base_class","observations":["Core base class for all services","Located in src/core/base_service.py","Business logic orchestration layer","Uses repositories for data access","Async operations throughout","Constructor takes session as primary parameter","Uses repositories for all data access","Session dependency injected from FastAPI","Business logic orchestration without direct database access","Generic typing with ModelType and SchemaType","Standard CRUD operations delegated to repositories"]}
{"type":"entity","name":"ConfigurationContentSeparation","entityType":"pattern","observations":["Configuration stored in local database (SQLite/PostgreSQL)","Actual content stored in external systems (Databricks Vector Search, Unity Catalog)","Database: Memory backend configurations, volume settings, authentication","Vector Search: Embedded memory content, similarity search, agent isolation","Unity Catalog Volumes: Raw file storage, document content","Clear separation between metadata and actual data storage","Vector Search: All memory indexes, embeddings, similarity search data","Vector Search: Agent memory content, knowledge retrieval, vector embeddings","Database (PostgreSQL/SQLite): Runs, executions, logs, audit trails","Database: Configuration settings, user accounts, crew definitions","Database: Authentication tokens, API keys, workspace settings","Database: Process status, execution history, system logs","Clear operational separation: Vector Search for AI memory, Database for application data"]}
{"type":"entity","name":"KnowledgeGraphEnforcementHooks","entityType":"automation_system","observations":["Automated workflow enforcement for CLAUDE.md compliance","Blocks file operations without prior knowledge graph consultation","Mandatory aim_search_nodes() or aim_read_graph() before Read/Write/Edit","PostToolUse reminders to update KG with aim_add_observations()","SessionStart enforcement of context loading","Located in .claude/settings.json and .claude/hooks/","Prevents the 'why search not working' issue through enforcement","Compliance logging in .claude/logs/"]}
{"type":"entity","name":"CleanArchitecturePattern","entityType":"pattern","observations":["Core architecture pattern used throughout Kasal","Separates concerns across API -> Services -> Repositories -> Database layers","Enforced in backend with FastAPI structure","Repository pattern with Unit of Work for transaction management"]}
{"type":"entity","name":"AsyncFirstPrinciple","entityType":"requirement","observations":["CRITICAL: All operations must be async and non-blocking","Enforced in backend services and database operations","Required for proper event loop handling","Prevents blocking in FastAPI server"]}
{"type":"entity","name":"ExecutionIsolation","entityType":"pattern","observations":["Each crew execution has isolated resources","Prevents data leakage between executions","Implemented in DatabricksVectorKnowledgeSource with execution_id","Collection names include execution_id for isolation","UPDATED: No longer implemented in DatabricksVectorKnowledgeSource (deleted)","Now implemented through DatabricksKnowledgeSearchTool execution_id parameter","Tool-based approach maintains execution isolation","Collection names still include execution_id for isolation"]}
{"type":"entity","name":"TenantIsolation","entityType":"pattern","observations":["Multi-tenant architecture with group_id isolation","Ensures complete separation between different user groups","Implemented in memory backends and knowledge sources","Group_id used in crew memory persistence"]}
{"type":"entity","name":"VectorSearchDirectAccess","entityType":"integration","observations":["Direct integration with Databricks Vector Search","Bypasses ChromaDB completely for knowledge sources","Uses document_index from memory backend configuration","Handles embeddings natively within Vector Search","Supports OBO authentication and PAT tokens","Repository pattern for Vector Search operations"]}
{"type":"entity","name":"MemoryLifecycle","entityType":"pattern","observations":["Memory creation starts in MemoryBackendFactory.create_memory_backends()","Factory creates DatabricksVectorStorage instances for each enabled memory type","Each storage instance wrapped with CrewAIDatabricksWrapper for CrewAI compatibility","Memory initialization includes: endpoint_name, index_name, crew_id, agent_id","Crew ID format: user_{group}_crew_{hash} for deterministic persistence","Hash generated from: agent roles, task names, crew name, model, run_name, group_id","Same crew configuration generates same ID across runs for persistence","Memory operations use async/await pattern with event loop management","USE_NULLPOOL=true prevents asyncpg connection pool conflicts","Memory saved with embedding generation using databricks-gte-large-en model","Search operations use similarity search with vector embeddings","Memory filtered by crew_id or group_id for isolation","Entity memory supports relationship-based retrieval with graph traversal","Memory persists in Databricks Vector Search indexes permanently"]}
{"type":"entity","name":"MemoryPersistenceStrategy","entityType":"pattern","observations":["Short-term: Session-scoped with 24-hour TTL sliding window","Long-term: Permanent storage of task descriptions for learning","Entity: Permanent knowledge graph with relationship persistence","Document: Permanent storage of uploaded knowledge files","All memories stored in Databricks Vector Search indexes","Index names configured in MemoryBackendConfig","Typical pattern: {catalog}.{schema}.{memory_type}_{group_id}","Example: users.nehme_tohme.short_term_memory_user_admin","Crew-specific isolation through crew_id filtering","Group-specific isolation through group_id for multi-tenancy","Agent-specific access control via agent_id field","Document access control via agent_ids JSON array","No automatic cleanup except short-term TTL expiration","Manual cleanup possible via clear() method"]}
{"type":"entity","name":"MemoryAccessPatterns","entityType":"pattern","observations":["Save pattern: Text → Embedding → Vector Storage → Index","Search pattern: Query → Embedding → Similarity Search → Results","CrewAI calls wrapper.save() during agent execution","CrewAI calls wrapper.search() or wrapper.load() for retrieval","Short-term: save(value, metadata) with session context","Long-term: save(LongTermMemoryItem) with task description","Entity: save('EntityName(Type): Description', metadata)","Document: Pre-chunked, accessed via knowledge sources","Wrapper handles async operations in sync context","ThreadPoolExecutor used for event loop isolation","Results formatted with 'context' field for CrewAI","Similarity scores included in search results","Entity memory supports get_entities() for listing","Relationship retrieval uses max_hops=2, weight=0.3"]}
{"type":"entity","name":"EmbeddingStrategy","entityType":"pattern","observations":["All text converted to 1024-dimension vectors","databricks-gte-large-en as default embedding model","Embeddings generated during save operations","Same embedder used for save and search consistency","DatabricksEmbeddingFunction handles generation","Custom embedder passed via config dictionary","Embedder accessed via __call__ or embed methods","numpy arrays converted to Python lists","Random embeddings generated for testing if needed","Embedding model tracked in embedding_model field","Consistent embeddings critical for search accuracy","Text normalization before embedding generation","Embeddings stored directly in Vector Search index","No separate embedding storage needed"]}
{"type":"entity","name":"KnowledgeSearchToolProposal","entityType":"design_proposal","observations":["Replace CrewAI knowledge source with tool-based approach","Tool provides explicit control over when knowledge is searched","Engine-agnostic service layer in databricks_knowledge_service.py","Lightweight CrewAI wrapper as DatabricksKnowledgeSearchTool","Agents can call tool directly: search_knowledge('What is kasal?')","No dependency on CrewAI's automatic knowledge retrieval","Easier to debug and test","Works with any future AI engine","Implementation completed successfully","Service layer added to databricks_knowledge_service.py","CrewAI tool wrapper created as DatabricksKnowledgeSearchTool","Tool registered in tool factory","Old knowledge source files removed","Agent configuration updated to remove knowledge_sources","Tool-based approach provides better control and debugging"]}
{"type":"entity","name":"DatabricksKnowledgeSearchTool","entityType":"component","observations":["Location: /engines/crewai/tools/custom/databricks_knowledge_search_tool.py","Inherits from CrewAI BaseTool","Input schema: query (string), group_id (optional), execution_id (optional)","Calls databricks_knowledge_service.search_knowledge()","Returns formatted search results","Handles async/sync conversion for CrewAI","Minimal CrewAI-specific logic","Registered in database as Tool ID 36","Enabled/disabled automatically based on knowledge_volume_enabled configuration","Frontend adds tool name to agent's tools array when files are uploaded","Tool resolution updated to handle both numeric IDs and tool names","Tool factory properly creates instance with group_id, execution_id, user_token","UI displays as 'Knowledge Search' instead of 'Tool1'","Synced with DatabricksConfiguration component for automatic enable/disable","CORRECTED LOCATION: src/backend/src/engines/crewai/tools/custom/databricks_knowledge_search_tool.py","File exists and is accessible in project structure"]}
{"type":"entity","name":"KnowledgeSearchService","entityType":"service","observations":["Location: databricks_knowledge_service.search_knowledge()","Engine-agnostic implementation","Uses DatabricksVectorIndexRepository for vector search","Parameters: query, group_id, execution_id, file_paths, limit","Returns list of search results with content and metadata","Handles authentication and error handling","Can be used by any engine or API endpoint"]}
{"type":"entity","name":"ToolResolutionSystem","entityType":"subsystem","observations":["Handles both numeric tool IDs from database and tool names","Located in /engines/crewai/helpers/tool_helpers.py","resolve_tool_ids_to_names() updated to pass through custom tool names","Special handling for DatabricksKnowledgeSearchTool as non-database tool","Maintains backward compatibility with numeric tool IDs","Prevents 'invalid literal for int()' errors for string tool names"]}
{"type":"entity","name":"DatabricksApps","entityType":"platform","observations":["Platform for building and deploying web applications within Databricks","Supports on-behalf-of user authentication","Integrates with SQL warehouses and Unity Catalog","Supports FastAPI, Streamlit, and Dash frameworks","Provides secure context-aware database access","Configuration via app.yaml manifest"]}
{"type":"entity","name":"Lakebase","entityType":"database","observations":["Fully-managed PostgreSQL OLTP engine inside Databricks","Provides row-level transactions and indexes","Supports JDBC/psql access with PostgreSQL semantics","Compatible with SQLAlchemy connections","Offers Synced Tables from Unity Catalog","Low-latency reads and writes for transactional workloads","Integrated authentication with Databricks Apps","Token-based temporary credential system"]}
{"type":"entity","name":"LakebaseIntegration","entityType":"design_proposal","observations":["Database backend option for Kasal when deployed to Databricks Apps","Replaces PostgreSQL with Lakebase for OLTP operations","Maintains Vector Search for AI memory and embeddings","Uses temporary token generation via Databricks SDK","PostgreSQL-compatible requiring minimal code changes","Supports existing Alembic migrations and SQLAlchemy models","Implements per-request token generation for security","Configurable via DATABASE_TYPE environment variable"]}
{"type":"entity","name":"HierarchicalProcessSupport","entityType":"feature","observations":["CrewAI built-in feature for manager-based task delegation","Requires Process.hierarchical enum value","Needs either manager_llm or manager_agent configuration","Manager coordinates and delegates tasks to specialist agents","Kasal partially supports through process parameter passing","Backend handles manager_llm but not manager_agent","Frontend lacks UI for process type selection","Implementation needed in crew_preparation.py and frontend components","Backend implementation completed in crew_preparation.py","Added Process enum import and proper conversion","Supports both manager_llm and manager_agent configurations","Config adapter enhanced to pass hierarchical settings","Falls back to appropriate defaults when manager not specified","Documentation created at src/docs/hierarchical-process.md","Frontend UI implementation still pending","Frontend UI implementation completed","Added process type selector in LeftSidebar Runtime Features section","Sequential/Hierarchical dropdown with descriptions","Manager LLM selector shows when hierarchical is selected","Process type and manager_llm passed to execution inputs","Updated CrewExecutionStore with processType and managerLLM state","ExecuteCrew and ExecuteTab functions updated to include process configuration","UI positioned between Planning and Reasoning sections for logical flow"]}
{"type":"entity","name":"X-Forwarded-Email-Flow","entityType":"pattern","observations":["Authentication pattern for SSO environments (Databricks Apps, OAuth2-Proxy)","Browser/Proxy sends X-Forwarded-Email header with every request","Backend dependencies.py extracts email from header in get_group_context()","Backend creates/updates user automatically from X-Forwarded-Email","Frontend fetches user via /users/me endpoint which returns email from header","Eliminates need for frontend to manage authentication in SSO mode","Ensures consistent user identity across all requests","GroupSelector and PermissionStore both rely on this flow for user identification"]}
{"type":"entity","name":"ThreeTierRoleModel","entityType":"pattern","observations":["Admin: Full system control, all capabilities","Editor: Workflow developer, can build/modify agents, tasks, crews","Operator: Execution operator, read-only access to workflows, can execute and monitor","Operators have read-only access to agent/task/crew definitions","Editors can create, update, delete agents/tasks/crews","All roles can execute workflows and monitor execution","Migration completed from old 4-tier system (Admin, Manager, User, Viewer)","New simplified mapping: Manager → Editor, User → Operator, Viewer → Operator","Decorator-based enforcement through @require_roles(['admin', 'editor', 'operator'])","Located in src/core/permissions.py with check_role_in_context() function","Replaces complex privilege-based system with simple role checking","All endpoints use decorators instead of privilege lookups","Group-scoped roles: users can have different roles in different groups","Role hierarchy: Admin (full control) > Editor (workflow dev) > Operator (execution only)","CORRECTED LOCATION: Located in src/backend/src/core/permissions.py with check_role_in_context() function","File exists and contains permission enforcement decorators"]}
{"type":"entity","name":"SimplifiedRBACMigration","entityType":"migration","observations":["Comprehensive cleanup of complex RBAC system completed","Removed 6 database tables: privileges, roles, role_privileges, external_identities, identity_providers, user_roles","Cleaned up 8 service files that used complex RBAC","Moved 6 broken test files to backup directory","Updated all documentation to reflect simplified 3-tier approach","Fixed import errors and runtime issues","AdminUserPrivilegesDep removed from dependencies","All routers now use simple role decorators","Database migration script: 6d23ffae21aa_drop_complex_rbac_tables.py","Alembic migration executed successfully"]}
{"type":"entity","name":"UnitOfWork","entityType":"pattern","observations":["Transaction management pattern for database operations","Currently manages 12 repositories in the system","5 services properly use dependency injection pattern","11 services create their own UoW context (anti-pattern)","6 services have factory methods (mixed pattern)","Located in src/core/unit_of_work.py","Recommendation: Standardize on constructor-based DI with router-level UoW creation","Critical analysis complete: Only 5 of 22 services actually need UoW","Services needing UoW: ProcessCrewExecutor, SchedulerService, MemoryBackendService, DatabricksKnowledgeService, CrewGenerationService","14 services don't need UoW and should use repositories directly","3 services might need UoW for complex operations only","Recommendation: Remove UoW from simple CRUD services to reduce complexity","Successfully refactored TemplateService to remove UoW","TemplateService now uses direct repository injection","Template router updated to inject service with repository","Pattern: Router gets SessionDep → creates service → service uses repository → repository uses session","2 of 14 services successfully simplified","Successfully refactored ToolService to remove UoW","ToolService now uses direct repository injection via constructor","Tools router updated to inject service with repository","Pattern consistently applied: Router → Service → Repository → Database","3 of 14 services successfully simplified (Schema, Template, Tool)","ANALYSIS COMPLETE: Pattern usage evaluated across 22 services","Only 5 services actually need UoW for complex operations","14 services successfully converted to direct repository pattern","SchemaService, TemplateService, and ToolService refactored to remove UoW","Pattern now used only where multi-repository transactions are essential"]}
{"type":"entity","name":"SimplifiedPermissionModel","entityType":"architecture_pattern","observations":["Replaced complex 4-tier RBAC with simple 3-tier role system","Eliminated privileges, role_privileges, external_identities tables","Decorator-based permission enforcement pattern","Group-scoped role assignment","Roles: admin (full control), editor (workflow dev), operator (execution only)"]}
{"type":"entity","name":"ToolBasedKnowledgePattern","entityType":"architecture_pattern","observations":["Migrated from CrewAI knowledge sources to tool-based approach","DatabricksKnowledgeSearchTool replaces automatic knowledge retrieval","Explicit agent control over knowledge search timing","Engine-agnostic knowledge service layer","Better debugging and testability"]}
{"type":"entity","name":"LakebaseIntegrationPattern","entityType":"architecture_pattern","observations":["Multi-database architecture supporting both PostgreSQL and Lakebase","Database router for connection selection","Token-based authentication for Lakebase","PostgreSQL compatibility layer","Configuration-driven database selection"]}
{"type":"entity","name":"X-Forwarded-Email-AuthPattern","entityType":"authentication_pattern","observations":["SSO authentication via X-Forwarded-Email header","Automatic user creation/update from email header","Frontend uses /users/me endpoint for user identification","Eliminates frontend authentication complexity","Supports Databricks Apps and OAuth2-Proxy"]}
{"type":"entity","name":"ComprehensiveDocumentationSystem","entityType":"documentation_system","observations":["Extensive documentation created for migration","MIGRATION_3TIER_ROLES.md: Migration guide and rationale","PERMISSION_UI_GUIDE.md: Frontend permission implementation","ROLE_SYSTEM.md: Role definitions and capabilities","SECURITY.md: Security model and best practices","ZUSTAND_PERMISSION_IMPLEMENTATION.md: State management guide","hierarchical-process.md: CrewAI hierarchical workflow documentation","knowledge-search-tool.md: Tool-based knowledge search guide","lakebase-integration.md: Database integration documentation","ui-knowledge-tool-usage.md: Frontend knowledge tool usage"]}
{"type":"entity","name":"SecurityModelEvolution","entityType":"migration_pattern","observations":["Evolution from SECURITY_MODEL.md to multiple focused docs","Old monolithic security model replaced with modular approach","Separation of concerns: roles, permissions, UI implementation","Historical preservation in SECURITY_MODEL_OLD.md","Quick reference guide for day-to-day operations"]}
{"type":"entity","name":"CrewAIMemoryPersistence","entityType":"memory_system","observations":["New CrewAI memory files: .aim/crewAI.jsonl, .aim/memory-crewAI.jsonl","Knowledge graph memory persistence for CrewAI context","Separate from main project memory","AI-specific knowledge and training context","Session persistence for CrewAI workflows"]}
{"type":"entity","name":"SecurityModel","entityType":"pattern","observations":["Two-tier permission system: User-level permissions and Workspace roles","User-level permissions: is_system_admin and is_personal_workspace_manager","Workspace roles: Admin, Editor, Operator","Complete data isolation between workspaces","Permission inheritance and resolution logic","Workspace-scoped configuration for Databricks, memory, volumes","Documentation updated in SECURITY.md with complete new model","Quick reference updated in SECURITY_QUICK_REFERENCE.md","Detailed role system documented in ROLE_SYSTEM.md","Migration from old admin workspace concept to new two-tier system","Clear separation between user properties and workspace roles","Test script created at /tmp/test_workspace_admin_permissions.py"]}
{"type":"entity","name":"SystemAdmin","entityType":"role","observations":["User property stored as is_system_admin boolean flag","Platform-wide administration capabilities","Can grant/revoke all user-level permissions","Automatic Admin role in every workspace","Manages system-wide settings (models, tools)","Only existing System Admins can grant this permission"]}
{"type":"entity","name":"PersonalWorkspaceManager","entityType":"role","observations":["User property stored as is_personal_workspace_manager boolean flag","Allows users to configure their personal workspace","Gets Admin role in personal workspace (not Editor)","Can configure Databricks, memory backend, volumes, knowledge base","Granted by System Admin only","Designed for power users, developers, data scientists"]}
{"type":"entity","name":"WorkspaceAdmin","entityType":"role","observations":["Workspace-specific role assignment","Full workspace control and configuration","Can manage workspace members in team workspaces","Configure Databricks, memory backend, volumes for workspace","System Admins always have this role","Personal Workspace Managers have this in their personal workspace"]}
{"type":"entity","name":"WorkspaceEditor","entityType":"role","observations":["Workspace-specific role assignment","Can create, edit, delete agents, tasks, crews","Can execute workflows and view logs","Cannot configure workspace settings","Default role for users in personal workspace","Typical for developers and data scientists"]}
{"type":"entity","name":"WorkspaceOperator","entityType":"role","observations":["Workspace-specific role assignment","Can only execute existing workflows","Can monitor execution status and view logs","Cannot create or modify anything","Read-only access to workflow definitions","Designed for business users and operations staff"]}
{"type":"entity","name":"WorkspaceIsolation","entityType":"principle","observations":["Complete data isolation between workspaces","All database records include group_id field","API endpoints filter by workspace context","Users cannot access data from other workspaces","Personal workspaces use user_[email] format","Team workspaces have explicit member management"]}
{"type":"entity","name":"PermissionResolution","entityType":"algorithm","observations":["System Admin always gets Admin role everywhere","Personal workspace: Personal Workspace Manager gets Admin, others get Editor","Team workspace: Uses explicitly assigned role","Permission checks cascade from user properties to workspace roles","is_workspace_admin() helper checks both personal and team contexts","Frontend and backend use consistent resolution logic"]}
{"type":"relation","from":"Kasal","to":"Backend","relationType":"contains"}
{"type":"relation","from":"Kasal","to":"Frontend","relationType":"contains"}
{"type":"relation","from":"Kasal","to":"CrewAI_Engine","relationType":"integrates_with"}
{"type":"relation","from":"Kasal","to":"Database","relationType":"uses"}
{"type":"relation","from":"Backend","to":"Database","relationType":"connects_to"}
{"type":"relation","from":"Backend","to":"CrewAI_Engine","relationType":"orchestrates"}
{"type":"relation","from":"Frontend","to":"Backend","relationType":"communicates_with"}
{"type":"relation","from":"FastAPI_Backend","to":"ProcessCrewExecutor","relationType":"delegates_to"}
{"type":"relation","from":"ProcessCrewExecutor","to":"CrewAIEngineService","relationType":"coordinates_with"}
{"type":"relation","from":"CrewAIEngineService","to":"LLM_Manager","relationType":"depends_on"}
{"type":"relation","from":"LLM_Manager","to":"Databricks_Integration","relationType":"integrates_with"}
{"type":"relation","from":"FastAPI_Backend","to":"Clean_Architecture","relationType":"implements"}
{"type":"relation","from":"Kasal","to":"ServiceArchitecturePattern","relationType":"implements"}
{"type":"relation","from":"ServiceArchitecturePattern","to":"UnitOfWorkPattern","relationType":"uses"}
{"type":"relation","from":"ServiceArchitecturePattern","to":"DependencyInjectionPattern","relationType":"uses"}
{"type":"relation","from":"ServiceArchitecturePattern","to":"RepositoryPattern","relationType":"uses"}
{"type":"relation","from":"Backend","to":"ServiceArchitecturePattern","relationType":"implements"}
{"type":"relation","from":"FastAPI_Backend","to":"ServiceArchitecturePattern","relationType":"implements"}
{"type":"relation","from":"Clean_Architecture","to":"ServiceArchitecturePattern","relationType":"realized_by"}
{"type":"relation","from":"RepositoryPattern","to":"BaseRepository","relationType":"implemented_by"}
{"type":"relation","from":"BaseService","to":"UnitOfWorkPattern","relationType":"implements"}
{"type":"relation","from":"BaseService","to":"DependencyInjectionPattern","relationType":"uses"}
{"type":"relation","from":"BaseRepository","to":"AsyncOperations","relationType":"implements"}
{"type":"relation","from":"DatabricksKnowledgeSearchTool","to":"KnowledgeSearchService","relationType":"calls"}
{"type":"relation","from":"KnowledgeSearchService","to":"DatabricksVectorIndexRepository","relationType":"uses"}
{"type":"relation","from":"KnowledgeSearchToolProposal","to":"DatabricksKnowledgeSearchTool","relationType":"specifies"}
{"type":"relation","from":"KnowledgeSearchToolProposal","to":"KnowledgeSearchService","relationType":"specifies"}
{"type":"relation","from":"ToolResolutionSystem","to":"DatabricksKnowledgeSearchTool","relationType":"resolves"}
{"type":"relation","from":"SimplifiedRBACMigration","to":"ThreeTierRoleModel","relationType":"implements"}
{"type":"relation","from":"SimplifiedRBACMigration","to":"Kasal","relationType":"modernizes"}
{"type":"relation","from":"ThreeTierRoleModel","to":"ServiceArchitecturePattern","relationType":"integrates_with"}
{"type":"relation","from":"SimplifiedPermissionModel","to":"PermissionsCore","relationType":"implemented_by"}
{"type":"relation","from":"ToolBasedKnowledgePattern","to":"DatabricksKnowledgeSearchTool","relationType":"implemented_by"}
{"type":"relation","from":"LakebaseIntegrationPattern","to":"DatabaseRouter","relationType":"implemented_by"}
{"type":"relation","from":"LakebaseIntegrationPattern","to":"LakebaseSession","relationType":"implemented_by"}
{"type":"relation","from":"X-Forwarded-Email-AuthPattern","to":"GroupSelector","relationType":"used_by"}
{"type":"relation","from":"SimplifiedPermissionModel","to":"PermissionGuard","relationType":"enforced_by"}
{"type":"relation","from":"DatabricksConfig","to":"EventDrivenConfigurationUpdates","relationType":"implements"}
{"type":"relation","from":"LakebaseIntegrationPattern","to":"Lakebase","relationType":"integrates_with"}
{"type":"relation","from":"Database","to":"Lakebase","relationType":"can_use"}
{"type":"relation","from":"SecurityModel","to":"SystemAdmin","relationType":"includes"}
{"type":"relation","from":"SecurityModel","to":"PersonalWorkspaceManager","relationType":"includes"}
{"type":"relation","from":"SecurityModel","to":"WorkspaceAdmin","relationType":"includes"}
{"type":"relation","from":"SecurityModel","to":"WorkspaceEditor","relationType":"includes"}
{"type":"relation","from":"SecurityModel","to":"WorkspaceOperator","relationType":"includes"}
{"type":"relation","from":"SecurityModel","to":"WorkspaceIsolation","relationType":"enforces"}
{"type":"relation","from":"SecurityModel","to":"PermissionResolution","relationType":"implements"}
{"type":"relation","from":"SystemAdmin","to":"WorkspaceAdmin","relationType":"always_has"}
{"type":"relation","from":"PersonalWorkspaceManager","to":"WorkspaceAdmin","relationType":"gets_in_personal"}
{"type":"relation","from":"PermissionResolution","to":"SystemAdmin","relationType":"checks"}
{"type":"relation","from":"PermissionResolution","to":"PersonalWorkspaceManager","relationType":"checks"}
{"type":"relation","from":"PermissionResolution","to":"WorkspaceAdmin","relationType":"resolves_to"}
{"type":"relation","from":"PermissionResolution","to":"WorkspaceEditor","relationType":"resolves_to"}
{"type":"relation","from":"PermissionResolution","to":"WorkspaceOperator","relationType":"resolves_to"}